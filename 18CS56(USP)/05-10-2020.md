# The here document (<<):

    * There are occassions when the data ur program reads is fixed and fairly limited the shell uses << symbol to read from the same file containing the script.
    This is referred to as here document signifying that the data is here rather than in a separate file

    * Any command using the standard input can also take input from the here document.
    This feature is useful when used with commands that do not accept a filename as argument ex mailx
    If the message is short you can have both the command and the message in the same script
        ```
            mailx cse << MARK
            > This is a test message
            > The message is sent on 5th oct 2020
            > MARK
        ```

# Using the here document with interactive programs

    * Many commands require the input from the user sometimes the input is keyed in as response to a series of questions posed by the command ex you may have to enter yes or no rather than waiting for input from the user we can ask the script to take the input from a here document

        ```
            echo "Enter the pattern to be searched: \c"
            read pname
            echo "Enter the file to be used: \c"
            read fname
            echo "Searching for $pname from file $flname"
            grep "$pname" $flname
            echo "Selected records shown above"
        ```
        ```
            sh emp1.sh << END
            >director
            >emp.lst
            >END
        ```

# set and shift(manipulating the positional parameters)

- some unix cmds like date produce single line output we also pass command ops thro filters like grep to produce single line output

- set assigns its arguments to the positional parameters $1, $2 ...so on

- This feature is especially useful for picking up individual fields from output of the program

## Use set to convert its args to positional parameters

```
    set 76 97 56
    # 76, 97, 56 is assigned to $1, $2, $3 respectively
    echo $1 $2 $3
    76 97 56

    echo "No of args: $#"
    3

    echo "Arguments = $*"
    Arguments = 76 97 56
```

- Extract individual fields from data output

```
set `date`
echo $*
Mon Oct 5 15:32:41 IST 2020

echo "Date is $2 $3 $6"
date is Oct 5 2020

echo $4
15:32:41
```

# Shift

- Many scripts use the first argument to indicate a separate entity say a file name the other arguments could then represent a series of strings probably different patterns to be selected from a file.

- For this to be possible for shld start its iterationfrom the second parameter onwards this is possible with the shift statement

- Shift transfers the contents of a positional parameter to its immediate lower numbered one

- when called once $2 becomes $1 and so on.

```
set `date`
echo "$@" #echoes all the parameters
Mon Oct 5 15:30:03 IST 2020
echo $1 $2 $3
Mon Oct 5
shift 1
echo "$@"
Oct 5 15:30:03 IST 2020
shift 2
echo "$@"
15:30:03 IST 2020
```

```
case $# in
    0|1) echo "Usage : $0 file pattern(s)"; exit2;;
    *) flname=$1
        shift
        for pattern in "$@"; do
            grep "$pattern" $flname || echo "Pattern $pattern not found..."
        done;;
esac

```

# USing while to wait for a file

- There are situations when a program needs to read a file that is created by another program but it also has to wait until the file is created
- monitfile.sh periodically monitors the disk for the existence of the file and then executes the program once the file has been located. It makes use of external sleep command which makes the script pause for the duration as specified by the argument. The loop executes repeatedly as long the file invoice.lst cannot be read
- If the file becomes readable the loop is terminated and the program echoes.
- monit.sh

```
whie [! -r invoice.lst]
do
    sleep 5
    echo '......'
done
echo "file is readable"
```

# Setting up an infinite loop

- suppose you want to see free space available on the disk every two minutes you need an infinite loop and it is implemented by using true as a dummy control command with while

```
while true
do
    df -t
    sleep 2
done

# run this in background so can get back prompt
# to kill
# kill $!
# used to kill the last background job
```

# basename: Changing filename extensions

- basename is used to change the extensions of a grp of filenames
- basename extracts the base filename from an absolute path name

```
basenmae /home/saaketh/a.txt
a.txt
```

```
for file in *txt
do
    echo $file
    leftname = "basename $file txt"
    mv $file ${filename}doc
done
```
