Unix


# Process control:
* Process control is concerned about creation of new processes, program execution and process termination.

# Process identifiers

```
#include<unistd.h>
pid_t getpid(void) - returns process id of calling process
pid_t getppid(void) - returns parent pid of calling process
pid_t getuid(void) - real uid of calling process
pid_t geteuid(void) - efective uid of calling process
pid_t getgid(void) - real gid of calling process
pid_t getegid(void) - efective gid of calling process

```

# fork function
* an existing process can create a new one by calling the fork function 

```
#include<unistd.h>
pid_t fork(void); - returns 0 in child, pid of child in parent, 1 - err. 

```
* The new process created by fork is called the child process
* The function is called once, but it returns twice
* A process can have more than one child
* A child can have only one parent
* Both child and parent continue executing with the instruction that follows the call to fork.
* A child is a copy of the parent.
* Child gets a copy of the parents data space, heap and stack.
* The parent and child share the text segment

# Program 1

```
#include<unistd.h>
#include<sys/types.h>

int main() {
    fork();
    printf('Hello unix\n');
}

op: Hello UNIX in child
    Hello UNIX in parent

```

# Program 2
```
#include<sys/types.h>
#include<unistd.h>

int main() {
    printf("before \n")
    fork()
    printf("Hello unix\n")
}

output: before (parent)
        Hello unix (parent)
        Hello unix (child)
```

# File sharing

* consider a process, whicih has opened 3 different files
- stdin, stdop, stderr
* it is important that the parent and child share the same file offset.
* Consider a process that forks a child and then wait for the child to complete
* if the parent has its standard op redirected it is essential the the parent file offset be updated by the child when the child writes to the standard output.
* in this case child can write to the standard output when the parent is waiting for it. On completion of child process parent can continue writing to the standard op knowing that its op will be appended to twhatever the child wrote
* If the parent and child did not share the same file offset this type of interaction wld have landed into problems.
* There are two normal cases for handling the desc after the fork 
    1. The parent waits for the child to complete. In this case the parent does not need todo with its descripters
    2. When the child terminates any of the shared descriptors that the child read from or wrote to will have their file offsets updated accordingly
    3. Both the parent and child executes simultaneously after the fork the parent closes the descriptor that it does not need and the child does the same thing. This way neither interfaces with the other open descriptor. This scenario is seen in the network servers.

# List of properties inherited to child
1. real UID
2. real GID
3. Controlling terminal
4. Current working directory
5. Root directory
6. File mode creation mask
7. Signal mask
8. Environment 
9. Resource limits

# The differences between parent and child are
- The return value from the fork
- The process ids are different
- The childs 
    1. tms_utime
    2. tms_stime
    3. tms_cutime
    4. tms_cstime

- File locks set by parent are not inherited to the child
- Pending alarms are cleared for the child
- The set of pending signals for the child is set to an empty set
* to main resons for the fork to file
    1. If tooooo many processes are already in the system
    2. The total number of processes, exceeds the system limit. 

* Two uses for fork() fns
    1. When a process wants to duplicate itself
        * used in network server
    2. When the process wants to execute a different program thsi is what happens in shell. Child exec after it returns from the fork.



