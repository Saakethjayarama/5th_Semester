opendir - open a dir file for read only, returns a directory handle

readdir - reads a record from dir file desc
rewinddir - reset the file ptr to the first
closedir - closes the dir file

# Device file APIs

- Device files are use to interface physical device with appln programs
- A process with su previlages can call mknod.
- The user id, grp id, attribs are a device file are assigned in the same manner as for regular files.
- when a process reads or writes to device file the kernel uses the major and minor device numbers of a file to select a device driver fn to carry out actual data transfer.
- device file support is implementation dependent
- mknod creates device files.

```
#include<sys/stat.h>
#include<unistd.h>

int mknod(pathname, mode, int deviceid)
pathnam:- pathname
mode:- access permission for user, grp and others also S_IFCHR/S_IBLK(whethr block or character device)
devid:- contains major and minor device no.

int main(int argc, char * char argv[]){
    if(argc != 4) {
        printf("usage: argv[0], file majorno minorno\n")
        exit(-1);
    }
    int major = atoi(argv[2], minor=atoi(argv[3]));
    mknod(argv[1], S_IFCHR | S_IRWXU | S_IRWXG | S_IRWXO, (major << 8 |  minor));
}

```

# FIFO file APIs

- fifo fileas are also called as named pipes.
  ex :- ls -ls | wc
  ls -ls | pg
  ls -ls | more
- pipes can be used only between related processes.
- creating a fifo is similar to creating a file
- mkfif0 is a fn

```
#include<sys/types.h>
#include<sys/stat.h>
#include<unistd.h>

int mkfifo(pathname, mode);

1 par - pathname
2 par - mode
on success: - 0
return -1 for failure

```

mkfifo("fifo1", S_IFIFO | S_IRWXU | S_IRGRP | S_ROTH);

```
- once we have created fifo using mkfiro we open it using open
- normal file operations read, write, link, unlink ..ext all work with fifo
- whenever a process opens a fifo for reading and writing the kernel will block the process automatically this provides a need for sync in case of inter process communication.
- another method to ceate fifo files for interprocess communication is to use the pipe system call

# include <unistd.h>
int pipe(int fds[2]);

0- succes
-1 - failure
```

- if the pipe call executes successfully, the process can read from fd[0]and write to fd[1].
- Ususally a parent process uses pipes to communicate with its children.

# Symoblic link file APIs:

- A symbolic link is an indirect ptr to a file
- unlike the hard links which pointed directly to the inode of the file
- symbolic links are developed to get around the limitations of hard disks
- symbolic links can link the files across file systems.
- symbolic links can link directory files
- symbolic links always reference the latest version of the file to which they link.
- there are no file system limitations on a symbolic link.
- symbolic links are typically used to move a file or an entire directory to some other location on a system.
- the symbolic link is created using a fn symlink
- the prototype is

```
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>

int symlink(org_link, sym_link)
```
