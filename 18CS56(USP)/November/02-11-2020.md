- The resource info includes statistical data such as

* The cpu time
* system time
* no of signals received

- The resource information is available only for terminated child process and not for the process stopped due to job control

- A race condition occurs when multiple processes are trying to do something with shared data and final outcome depends on the order in which the processes run

Example program
the program below outputs two string one from the child and other from the parent. The program contains a race condition because the output depends on the order in which the processes are run by the kernel and for how long each process runs.

```
static void charatatime(char *);

int main() {

    pid_t pid;
    if((pid = fork()) < 0){
        printf("Fork err\n")
    }else if(pid = 0){
        charatatime("output from child");
    }else {
        charatatime("output from parent")
    }
    exit(0);
}

static void charatatime(char *str) {
    char *str;
    int c;

    setbuf(stdout, NULL);
    for (ptr = str; (c = *ptr++)!=0){
        putc(c, stdout);
    }
}

output:
ooutput from child
utput from parent


```

# Program modification to avoid race condition.(imp)

```
TELL_WAIT();
WAIT_PARENT();
TELL_CHILD();

static void charatatime(char *);

int main() {
    pid_t pid;
    TELL_WAIT();
    if ((pic = forl()) < 0){
        printf('fork err')
    }else if(pid == 0) {
        WAIT_PARENT();
        charatatime('output from child');
    }else {
        charatatime('putpu from parent');
        TELL_CHILD();
    }
    exit(0);
}
```

# exec fun

system(); for runnin the unix commands from the c program
when a process calls one of the exedc fns, that process is completely replaced by the nwe program, and the new program starts executing at tits main function.

exec("ps -el");

the pid does not change across an exec.
becoz a new process is not created. exec merely replaces the current process its text, data, heap and stack segments, with a brand new program from disk.

There are 6 exec fns.

```
#include<unistd.h>

int execl()
int execv()
int execle()
int ececve()
int ececlp()
int execvp()
```

- -1 for err
- no return value for success

- First 4 fns, take pathname argument
- last 2 fns takes filename argument
- if the filename contains a slash, it is taken as a pathname
- the system searches the directories listed in path variable for executable file.
- l stands for list
- v stands for vector
- The functions execl, execlp, execle require each of the command line arguments to the new program to be specified as separate arguments.

- The other three fns, execv, execvp and execve, we have to build an array of pointers to the arguments.
- The address of this array is the argument to these three functions.

- Next difference is the passing of the environment list to the new programs

- For whose names ends with e - allow us to pass a ptr to an array of ptrs to the new env strings. the other 4 fns use the environ variable in the calling process.

- Note: The process id does not change but the new program inherits additional properties from the calling process.

- Process ID and parent process ID
- real UID and GID
- controlling terminal
- current working directory
- root directory
- file mode creation mask
- file locks
- process signal mask
- pending signals
- resource limits

Example of exec function:

```

#include<sys/wait.h>

char *env_init[] = {
    "USER=UNKNOWN",
    "PATH=/tmp",
    NULL
};

int main(){
    pid_t pid;
    if((pid == fork()) < 0>){
        printf("fork err")
    }else if(pid == 0) {
        if ( execle("/home/xyz/echoall", "echoall", "myarg1", "myarg2", (char *)0, env_init) < 0) {
            printf("exec err");
        }
    }
    if(waitpid(pid, NULL, 0) < 0)
        printf("wait err")

    if((pid=fork()) < 0>)
        printf("fork err")
    else if(pid == 0){
        if(execlp("echoall", "echoall", "only arg", (char *)0) < 0) {
            printf("execlp err");
        }
    }
    exit(0);
}
output:
    argv[0]: echoall
        [1]: myarg1
        [2]: myarg2
    USER=UNKNOWN
    PATH=/tmp,

    argv[0]: echoall
        [1]: only one argument
    all shell vars
    USER = xxxx
    LOGNAME = XXXX
    SHELL = /bin/sh
    HOME = /home/xxx
```
