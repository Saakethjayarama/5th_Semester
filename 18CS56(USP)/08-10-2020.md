int fstat(fd, struct stat \*statv)

struct stat{
st_dev file system id
st_ino inode no
st_mode - file type / permissions
st_nlink - no of link
st_uid - uid
st_gid - gid
st_size - size in bytes
st_atime - last acess time
st_mtime - last modified time
st_ctime - last status change time
}

returns 0 -for success
-1 - error
macros type of file
S_ISREG() Is Regular file
S_ISDIR() Is directory
S_ISCHR() char specified file
S_ISBLK() block special file
S_ISFIFO() pipe of fifo
S_ISLINK() symbolic link
S_ISSOCK() socket

# access

- It checks the existence and access permission of user

```
#include<unistd.h>
int access(pathname, flag)
0 - success
-1 - failure

bit_flags   uses
F_OK        checks whther the file exist
R_OK        test for read permission
W_OK        test for write permission
X_OK        test for execute permission

int rc = access("x.txt", R_OK);

if(access("x.txt", F_OK) == -1)
    printf("file doesnt exist")
else
    printf("file exist")
```

# chmod, fchmod

- It allows us to change the file access permission for owner(user) and grp and for others

- a process must have effective uid of either the superuser or owner of the file

```
#incluse<sys/types.h>
#incluse<sys/stat.h>
#include<uni/std.h>

int chmod(pathname, flag)
int fchmod(fd, flag)

flags:
    S_IRWXU - read, write, execute for user
    S_IRUSR - read for user
    S_IWUSR - write for user
    S_IXUSR - execute for user

```

# chown, fchown

- Change owner fn changes user id, and grp id of files.

```
#include<unistd.h>
#include<sys/types.h>

int chown(name, uid, gid)
int fchown(fd, uid, gid)


```

# utime

- It modifies the access time and the modification timestamps of a file

```
#include<sys/types.h>
#include<unistd.h>
#include<utime.h>


int utime(pathname, struct utimebuffer * times)
0 for success
-1 for failure

struct utimebuffer {
    time_t actime; // access time
    time_t modtime; // modification time
}
```

# File and record locking

- multiple process perform read and write operation on the same file concurrently
- facilitates data sharing
- challenge is to maintain integrety of data without any conflicts
- to solve this problem unix and posix standards supports the file and record locking mechanism
- file locking is applicable for _regular_ files
- a process can impose read or write lock on either entire file or portion of file
- the intension of write lock is to prevent other processes from both reading and writing the locked region.
- the use of read lock is to prevent other processes from writing to the locked region.
- write lock is called as exclusive lock and read lock is called shared lock
- these locking mechanism can be used to synchronise reading and writing of shared files by mulitple processes
- the process has to wait until the lock is released
- procedure for read or write of a file
  1. try to set the lock at region of access
  2. if this fails a process can either wait for the lock request to become successfull
  3. after lock is accessed successfyll conduct read or write operation on the blocked region
  4. release the lock

```
l2 is a lock from 0 -512 assume it is write lock
and if we apply lock(Read lock) l1 from 0-256
l1 is covered under l2 therefore the process has onlyh l2 lock this concept is called lock promotion

if the process unblocks from 128 to 480 (release write lock)
then the process will have 2 locks
one lock from 0-127 and other from 480-512 this is called lock splitting

```

- Unix system provides fcntl fn to support file locking by usning fcntl it is possible to impose read or write lock on either a regio or an entire file.

```
#include<fcnt.h>
int fcntl(int fd, int cmd_flag, ....)

cmd_flag
F_SETLK - it sets a file lock if it doesnt succeed immeadiately (then do not bock if this cannot succeed immediately)

F_SETLKW - sets a file lock and blocks the process until the lock is acquired.

F_GETLK - it queries as to which process locked a specified region of a file.

for file locking 3rd arg is the address of structure flock type variable this variable specifies a region of file where lock is to be set unset or queried

struct flock
{
    short l_type;
    short l_whence;
    off_t l_stat;
    off_t l_len;
    pid_t l_pid;
}

ltype:
    F_RDLCK
    F_WRLCK
    F_UNLCK

    l_whence
    l_start
    l_len
    defines the region of file to be locked or unlocked
```

```
#include<unistd.h>
#include<fcntl.h>

int main() {
    int fd;
    struct flock lock

    fd = open("x.txt", O_READONLY)
    lock.l_type = F_RDLCK;
    lock.l_whence = 0;
    lock.l_start = 10; start from byte 10
    lock.l_len = 15; go upto 15 bytes
    fcntl(fd, F_SETLK, &lock)

}
```
